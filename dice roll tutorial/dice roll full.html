<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js Dice Roller | Codrops</title>
    <meta
      name="description"
      content="Demo for the tutorial on how to code a dice roller with Three.js and cannon-es"
    />
    <meta
      name="keywords"
      content="3d dice, three.js, cannon-es, webgl, rolling dice"
    />
    <meta name="author" content="Codrops" />
    <link rel="shortcut icon" href="favicon.ico" />

    <style>
      *,
      *::after,
      *::before {
        box-sizing: border-box;
      }

      :root {
        font-size: 16px;
        --color-text: #000;
        --color-bg: #ddd;
        --color-link: #888;
        --color-link-hover: #000;
      }

      body {
        margin: 0;
        color: var(--color-text);
        background-color: var(--color-bg);
        font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica,
          Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        overflow: hidden;
      }

      /* Page Loader */
      .js .loading::before,
      .js .loading::after {
        content: "";
        position: fixed;
        z-index: 1000;
      }

      .js .loading::before {
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--color-bg);
      }

      .js .loading::after {
        top: 50%;
        left: 50%;
        width: 60px;
        height: 60px;
        margin: -30px 0 0 -30px;
        border-radius: 50%;
        opacity: 0.4;
        background: var(--color-link);
        animation: loaderAnim 0.7s linear infinite alternate forwards;
      }

      @keyframes loaderAnim {
        to {
          opacity: 1;
          transform: scale3d(0.5, 0.5, 1);
        }
      }

      a {
        text-decoration: none;
        color: var(--color-link);
        outline: none;
        cursor: pointer;
      }

      a:hover {
        color: var(--color-link-hover);
        outline: none;
      }

      /* Better focus styles from https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible */
      a:focus {
        /* Provide a fallback style for browsers
       that don't support :focus-visible */
        outline: none;
        background: lightgrey;
      }

      a:focus:not(:focus-visible) {
        /* Remove the focus indicator on mouse-focus for browsers
       that do support :focus-visible */
        background: transparent;
      }

      a:focus-visible {
        /* Draw a very noticeable focus style for
       keyboard-focus on browsers that do support
       :focus-visible */
        outline: 2px solid red;
        background: transparent;
      }

      main {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      .unbutton {
        background: none;
        border: 0;
        padding: 0;
        margin: 0;
        font: inherit;
        cursor: pointer;
      }

      .unbutton:focus {
        outline: none;
      }

      .frame {
        color: var(--color-title);
        padding: 1.5rem;
        display: grid;
        grid-template-columns: auto auto 1fr;
        grid-template-rows: auto;
        grid-template-areas: "title prev sponsor";
        justify-content: start;
        grid-gap: 2rem;
        z-index: 1000;
      }

      .frame a:not(.frame__title-back) {
        white-space: nowrap;
        overflow: hidden;
        position: relative;
      }

      .frame a:not(.frame__title-back)::before {
        content: "";
        height: 1px;
        width: 100%;
        background: currentColor;
        position: absolute;
        top: 90%;
        transition: transform 0.3s;
        transform-origin: 0% 50%;
      }

      .frame a:not(.frame__title-back):hover::before {
        transform: scaleX(0);
        transform-origin: 100% 50%;
      }

      .frame__title {
        grid-area: title;
        display: flex;
      }

      .frame__title-main {
        font-size: 1rem;
        margin: 0;
        font-weight: normal;
      }

      .frame__title-back {
        position: relative;
        display: flex;
        align-items: flex-end;
        margin-bottom: 0.15rem;
      }

      .frame__title-back span {
        display: none;
      }

      .frame__title-back svg {
        fill: currentColor;
      }

      .frame__prev {
        grid-area: prev;
      }

      .content {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      canvas {
        position: absolute;
        top: 0;
        left: 0;
      }

      .ui-controls {
        position: relative;
        width: 100%;
        max-width: 500px;
        font-family: inherit;
        user-select: none;
        line-height: 1.5;
        padding: 10px;
        pointer-events: none;
      }

      .score {
        font-weight: bold;
      }

      .ui-controls #score-result {
        display: inline-block;
        min-width: 1.8em;
        color: #d45f2e;
      }
      .ui-controls #score-result:after {
        content: "\200b";
      }
      .ui-controls #roll-btn {
        background-color: #273e9a;
        font-weight: bold;
        color: #ffffff;
        border: none;
        padding: 1em 1.5em;
        border-radius: 1.5em;
        text-decoration: none;
        display: inline-block;
        cursor: pointer;
        margin: 2em 0 0 0;
        transition: background-color 0.2s, transform 0.1s;
        pointer-events: auto;
      }
      .ui-controls #roll-btn:active {
        transform: translateY(2px);
      }
      .ui-controls #roll-btn:hover {
        background-color: #3737af;
      }
    </style>
    <script>
      document.documentElement.className = "js";
      var supportsCssVars = function () {
        var e,
          t = document.createElement("style");
        return (
          (t.innerHTML = "root: { --tmp-var: bold; }"),
          document.head.appendChild(t),
          (e = !!(
            window.CSS &&
            window.CSS.supports &&
            window.CSS.supports("font-weight", "var(--tmp-var)")
          )),
          t.parentNode.removeChild(t),
          e
        );
      };
      supportsCssVars() ||
        alert(
          "Please view this demo in a modern browser that supports CSS Variables."
        );
    </script>
    <script src="//tympanus.net/codrops/adpacks/analytics.js"></script>
  </head>
  <body>
    <main>
      <div class="frame">
        <div class="frame__title">
          <h1 class="frame__title-main">Three.js Dice Roller</h1>
          <a
            aria-label="Back to the article"
            class="frame__title-back"
            href="https://tympanus.net/codrops/?p=69521"
          >
            <span class="oh__inner">Back to the article</span>
            <svg width="18px" height="18px" viewBox="0 0 24 24">
              <path
                vector-effect="non-scaling-stroke"
                d="M18.25 15.5a.75.75 0 00.75-.75v-9a.75.75 0 00-.75-.75h-9a.75.75 0 000 1.5h7.19L6.22 16.72a.75.75 0 101.06 1.06L17.5 7.56v7.19c0 .414.336.75.75.75z"
              ></path>
            </svg>
          </a>
        </div>
        <a
          class="frame__prev"
          href="https://tympanus.net/Development/TwistedText/"
          >Previous demo</a
        >
      </div>
      <div class="content">
        <canvas id="canvas"></canvas>
        <div class="ui-controls">
          <div class="score">Score: <span id="score-result"></span></div>
          <button id="roll-btn">Throw the dice</button>
        </div>
      </div>
    </main>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.138.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.138.0/examples/jsm/"
        }
      }
    </script>
    <script src="https://tympanus.net/codrops/adpacks/cda_sponsor.js"></script>
    <script type="module">
      import * as CANNON from "https://cdn.skypack.dev/cannon-es";

      import * as THREE from "three";
      import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";

      const canvasEl = document.querySelector("#canvas");
      const scoreResult = document.querySelector("#score-result");
      const rollBtn = document.querySelector("#roll-btn");

      let renderer, scene, camera, diceMesh, physicsWorld;

      const params = {
        numberOfDice: 2,
        segments: 40,
        edgeRadius: 0.07,
        notchRadius: 0.12,
        notchDepth: 0.1,
      };

      const diceArray = [];

      initPhysics();
      initScene();

      window.addEventListener("resize", updateSceneSize);
      window.addEventListener("dblclick", throwDice);
      rollBtn.addEventListener("click", throwDice);

      function initScene() {
        renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true,
          canvas: canvasEl,
        });
        renderer.shadowMap.enabled = true;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          300
        );
        camera.position.set(0, 0.5, 4).multiplyScalar(7);

        updateSceneSize();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const topLight = new THREE.PointLight(0xffffff, 0.5);
        topLight.position.set(10, 15, 0);
        topLight.castShadow = true;
        topLight.shadow.mapSize.width = 2048;
        topLight.shadow.mapSize.height = 2048;
        topLight.shadow.camera.near = 5;
        topLight.shadow.camera.far = 400;
        scene.add(topLight);

        createFloor();
        diceMesh = createDiceMesh();
        for (let i = 0; i < params.numberOfDice; i++) {
          diceArray.push(createDice());
          addDiceEvents(diceArray[i]);
        }

        throwDice();

        render();
      }

      function initPhysics() {
        physicsWorld = new CANNON.World({
          allowSleep: true,
          gravity: new CANNON.Vec3(0, -50, 0),
        });
        physicsWorld.defaultContactMaterial.restitution = 0.3;
      }

      function createFloor() {
        const floor = new THREE.Mesh(
          new THREE.PlaneGeometry(1000, 1000),
          new THREE.ShadowMaterial({
            opacity: 0.1,
          })
        );
        floor.receiveShadow = true;
        floor.position.y = -7;
        floor.quaternion.setFromAxisAngle(
          new THREE.Vector3(-1, 0, 0),
          Math.PI * 0.5
        );
        scene.add(floor);

        const floorBody = new CANNON.Body({
          type: CANNON.Body.STATIC,
          shape: new CANNON.Plane(),
        });
        floorBody.position.copy(floor.position);
        floorBody.quaternion.copy(floor.quaternion);
        physicsWorld.addBody(floorBody);
      }

      function createDiceMesh() {
        const boxMaterialOuter = new THREE.MeshStandardMaterial({
          color: 0xeeeeee,
        });
        const boxMaterialInner = new THREE.MeshStandardMaterial({
          color: 0x000000,
          roughness: 0,
          metalness: 1,
          side: THREE.DoubleSide,
        });

        const diceMesh = new THREE.Group();
        const innerMesh = new THREE.Mesh(
          createInnerGeometry(),
          boxMaterialInner
        );
        const outerMesh = new THREE.Mesh(createBoxGeometry(), boxMaterialOuter);
        outerMesh.castShadow = true;
        diceMesh.add(innerMesh, outerMesh);

        return diceMesh;
      }

      function createDice() {
        const mesh = diceMesh.clone();
        scene.add(mesh);

        const body = new CANNON.Body({
          mass: 1,
          shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)),
          sleepTimeLimit: 0.1,
        });
        physicsWorld.addBody(body);

        return { mesh, body };
      }

      function createBoxGeometry() {
        let boxGeometry = new THREE.BoxGeometry(
          1,
          1,
          1,
          params.segments,
          params.segments,
          params.segments
        );

        const positionAttr = boxGeometry.attributes.position;
        const subCubeHalfSize = 0.5 - params.edgeRadius;

        for (let i = 0; i < positionAttr.count; i++) {
          let position = new THREE.Vector3().fromBufferAttribute(
            positionAttr,
            i
          );

          const subCube = new THREE.Vector3(
            Math.sign(position.x),
            Math.sign(position.y),
            Math.sign(position.z)
          ).multiplyScalar(subCubeHalfSize);
          const addition = new THREE.Vector3().subVectors(position, subCube);

          if (
            Math.abs(position.x) > subCubeHalfSize &&
            Math.abs(position.y) > subCubeHalfSize &&
            Math.abs(position.z) > subCubeHalfSize
          ) {
            addition.normalize().multiplyScalar(params.edgeRadius);
            position = subCube.add(addition);
          } else if (
            Math.abs(position.x) > subCubeHalfSize &&
            Math.abs(position.y) > subCubeHalfSize
          ) {
            addition.z = 0;
            addition.normalize().multiplyScalar(params.edgeRadius);
            position.x = subCube.x + addition.x;
            position.y = subCube.y + addition.y;
          } else if (
            Math.abs(position.x) > subCubeHalfSize &&
            Math.abs(position.z) > subCubeHalfSize
          ) {
            addition.y = 0;
            addition.normalize().multiplyScalar(params.edgeRadius);
            position.x = subCube.x + addition.x;
            position.z = subCube.z + addition.z;
          } else if (
            Math.abs(position.y) > subCubeHalfSize &&
            Math.abs(position.z) > subCubeHalfSize
          ) {
            addition.x = 0;
            addition.normalize().multiplyScalar(params.edgeRadius);
            position.y = subCube.y + addition.y;
            position.z = subCube.z + addition.z;
          }

          const notchWave = (v) => {
            v = (1 / params.notchRadius) * v;
            v = Math.PI * Math.max(-1, Math.min(1, v));
            return params.notchDepth * (Math.cos(v) + 1);
          };
          const notch = (pos) => notchWave(pos[0]) * notchWave(pos[1]);

          const offset = 0.23;

          if (position.y === 0.5) {
            position.y -= notch([position.x, position.z]);
          } else if (position.x === 0.5) {
            position.x -= notch([position.y + offset, position.z + offset]);
            position.x -= notch([position.y - offset, position.z - offset]);
          } else if (position.z === 0.5) {
            position.z -= notch([position.x - offset, position.y + offset]);
            position.z -= notch([position.x, position.y]);
            position.z -= notch([position.x + offset, position.y - offset]);
          } else if (position.z === -0.5) {
            position.z += notch([position.x + offset, position.y + offset]);
            position.z += notch([position.x + offset, position.y - offset]);
            position.z += notch([position.x - offset, position.y + offset]);
            position.z += notch([position.x - offset, position.y - offset]);
          } else if (position.x === -0.5) {
            position.x += notch([position.y + offset, position.z + offset]);
            position.x += notch([position.y + offset, position.z - offset]);
            position.x += notch([position.y, position.z]);
            position.x += notch([position.y - offset, position.z + offset]);
            position.x += notch([position.y - offset, position.z - offset]);
          } else if (position.y === -0.5) {
            position.y += notch([position.x + offset, position.z + offset]);
            position.y += notch([position.x + offset, position.z]);
            position.y += notch([position.x + offset, position.z - offset]);
            position.y += notch([position.x - offset, position.z + offset]);
            position.y += notch([position.x - offset, position.z]);
            position.y += notch([position.x - offset, position.z - offset]);
          }

          positionAttr.setXYZ(i, position.x, position.y, position.z);
        }

        boxGeometry.deleteAttribute("normal");
        boxGeometry.deleteAttribute("uv");
        boxGeometry = BufferGeometryUtils.mergeVertices(boxGeometry);

        boxGeometry.computeVertexNormals();

        return boxGeometry;
      }

      function createInnerGeometry() {
        const baseGeometry = new THREE.PlaneGeometry(
          1 - 2 * params.edgeRadius,
          1 - 2 * params.edgeRadius
        );
        const offset = 0.48;
        return BufferGeometryUtils.mergeBufferGeometries(
          [
            baseGeometry.clone().translate(0, 0, offset),
            baseGeometry.clone().translate(0, 0, -offset),
            baseGeometry
              .clone()
              .rotateX(0.5 * Math.PI)
              .translate(0, -offset, 0),
            baseGeometry
              .clone()
              .rotateX(0.5 * Math.PI)
              .translate(0, offset, 0),
            baseGeometry
              .clone()
              .rotateY(0.5 * Math.PI)
              .translate(-offset, 0, 0),
            baseGeometry
              .clone()
              .rotateY(0.5 * Math.PI)
              .translate(offset, 0, 0),
          ],
          false
        );
      }

      function addDiceEvents(dice) {
        dice.body.addEventListener("sleep", (e) => {
          dice.body.allowSleep = false;

          const euler = new CANNON.Vec3();
          e.target.quaternion.toEuler(euler);

          const eps = 0.1;
          let isZero = (angle) => Math.abs(angle) < eps;
          let isHalfPi = (angle) => Math.abs(angle - 0.5 * Math.PI) < eps;
          let isMinusHalfPi = (angle) => Math.abs(0.5 * Math.PI + angle) < eps;
          let isPiOrMinusPi = (angle) =>
            Math.abs(Math.PI - angle) < eps || Math.abs(Math.PI + angle) < eps;

          if (isZero(euler.z)) {
            if (isZero(euler.x)) {
              showRollResults(1);
            } else if (isHalfPi(euler.x)) {
              showRollResults(4);
            } else if (isMinusHalfPi(euler.x)) {
              showRollResults(3);
            } else if (isPiOrMinusPi(euler.x)) {
              showRollResults(6);
            } else {
              // landed on edge => wait to fall on side and fire the event again
              dice.body.allowSleep = true;
            }
          } else if (isHalfPi(euler.z)) {
            showRollResults(2);
          } else if (isMinusHalfPi(euler.z)) {
            showRollResults(5);
          } else {
            // landed on edge => wait to fall on side and fire the event again
            dice.body.allowSleep = true;
          }
        });
      }

      function showRollResults(score) {
        if (scoreResult.innerHTML === "") {
          scoreResult.innerHTML += score;
        } else {
          scoreResult.innerHTML += "+" + score;
        }
      }

      function render() {
        physicsWorld.fixedStep();

        for (const dice of diceArray) {
          dice.mesh.position.copy(dice.body.position);
          dice.mesh.quaternion.copy(dice.body.quaternion);
        }

        renderer.render(scene, camera);
        requestAnimationFrame(render);
      }

      function updateSceneSize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function throwDice() {
        scoreResult.innerHTML = "";

        diceArray.forEach((d, dIdx) => {
          d.body.velocity.setZero();
          d.body.angularVelocity.setZero();

          d.body.position = new CANNON.Vec3(6, dIdx * 1.5, 0);
          d.mesh.position.copy(d.body.position);

          d.mesh.rotation.set(
            2 * Math.PI * Math.random(),
            0,
            2 * Math.PI * Math.random()
          );
          d.body.quaternion.copy(d.mesh.quaternion);

          const force = 3 + 5 * Math.random();
          d.body.applyImpulse(
            new CANNON.Vec3(-force, force, 0),
            new CANNON.Vec3(0, 0, 0.2)
          );

          d.body.allowSleep = true;
        });
      }
    </script>
  </body>
</html>
